mytreeClust <- function(dfx, d.num = 1, col.range = 1:ncol(dfx), verbose = F, 
          final.algorithm, k, control = treeClust.control(), rcontrol = rpart.control(), weights = NULL, 
          ...) 
{
        if (!is.data.frame(dfx)) 
                stop("This function requires a data frame")
        leaf.matrix <- as.data.frame(matrix(0, nrow(dfx), ncol(dfx)))
        dimnames(leaf.matrix) <- dimnames(dfx)
        nm <- names(dfx)
        if (length(grep(" ", nm) > 0)) 
                stop("Some columns have embedded spaces in their names, and that's not good.")
        additional.args <- list(...)
        if (!missing(final.algorithm)) {
                if (!is.element(final.algorithm, c("agnes", "pam", "clara", 
                                                   "kmeans"))) 
                        stop("Unrecognized final algorithm")
                if (missing(k)) 
                        if (is.element(final.algorithm, c("kmeans", "pam", 
                                                          "clara"))) 
                                stop("With kmeans, pam or clara, specify the number of clusters 'k'")
                else k <- -1
                if (k == -1 & control$cluster.only == T) 
                        stop("Cluster.only TRUE requires k")
        }
        results <- matrix(0, nrow = ncol(dfx), ncol = 2)
        dimnames(results) <- list(dimnames(dfx)[[2]], c("DevRat", 
                                                        "Size"))
        control$keep.trees <- FALSE
        if (control$return.trees || control$return.newdata || d.num == 
            4 || (!missing(final.algorithm) && is.element(final.algorithm, 
                                                          c("clara", "pam", "kmeans"))) || (control$return.dists && 
                                                                                            d.num == 3)) {
                control$keep.trees <- TRUE
                big.list.of.trees <- vector("list", ncol(dfx))
        }
        parproc <- FALSE
        if (is.numeric(control$parallelnodes) && control$parallelnodes > 
            1) {
                cl <- parallel::makePSOCKcluster(round(control$parallelnodes))
                on.exit(parallel::stopCluster(cl))
                parproc <- TRUE
        }
        if (parproc) {
                caout <- parallel::clusterApplyLB(cl, col.range, my_treeClustrpart, 
                                                  dfx = dfx, d.num = d.num, control = control, rcontrol = rcontrol, weights = weights)
                keepers <- sapply(caout, function(x) x$Size > 1)
                leaf.matrix <- as.data.frame(sapply(caout[keepers], 
                                                    function(x) x$leaf.where))
                names(leaf.matrix) <- names(dfx)[col.range][keepers]
                results <- as.data.frame(t(sapply(caout, function(x) unlist(x[1:2]))))
                if (control$keep.trees) 
                        big.list.of.trees <- lapply(caout[keepers], function(x) x$tree)
        }
        else {
                for (i in col.range) {
                        if (verbose > 0) 
                                cat("Creating rpart tree with column", i, "\n")
                        
                        out.i <- my_treeClustrpart(i, dfx, d.num, control, 
                                                 rcontrol, weights = weights)
                        
                        results[i, ] <- c(out.i$DevRat, out.i$Size)
                        if (results[i, "Size"] > 1) {
                                leaf.matrix[, i] <- out.i$leaf.where
                                if (control$keep.trees) 
                                        big.list.of.trees[[i]] <- out.i$tree
                        }
                }
                if (control$keep.trees) 
                        big.list.of.trees <- big.list.of.trees[results[, 
                                                                       "Size"] > 1]
                leaf.matrix <- leaf.matrix[, results[, "Size"] > 1, 
                                           drop = F]
        }
        if (!any(results[, "Size"] > 1)) 
                stop("No tree produced anything! Panic!")
        original.results <- results
        results <- results[results[, "Size"] > 1, , drop = F]
        if (control$return.dists == TRUE || (!missing(final.algorithm) && 
                                             is.element(final.algorithm, c("pam", "agnes")))) {
                dists <- tcdist(tbl = results, mat = leaf.matrix, trees = big.list.of.trees, 
                                d.num = d.num)
        }
        if (control$return.newdata == TRUE || (!missing(final.algorithm) && 
                                               is.element(final.algorithm, c("kmeans", "clara")))) {
                newdata <- tcnewdata(tbl = results, mat = leaf.matrix, 
                                     trees = big.list.of.trees, d.num = d.num)
        }
        if (missing(final.algorithm)) {
                final.algorithm <- "None"
                final.clust <- NULL
        }
        else {
                if (final.algorithm == "agnes") {
                        final.clust <- do.call(final.algorithm, list(x = dists, 
                                                                     ...))
                        final.clust$call$x <- "deleted"
                        if (control$cluster.only == TRUE) 
                                final.clust <- cutree(final.clust, k = k)
                }
                if (final.algorithm == "pam") {
                        final.clust <- do.call(final.algorithm, list(x = dists, 
                                                                     k = k, ...))
                        final.clust$call$x <- "deleted"
                        if (control$cluster.only == TRUE) 
                                final.clust <- final.clust$clustering
                }
                if (is.element(final.algorithm, c("clara", "kmeans"))) {
                        if (final.algorithm == "kmeans") 
                                final.clust <- kmeans(x = newdata, centers = k)
                        else final.clust <- clara(x = newdata, k = k)
                        if (control$cluster.only == TRUE) 
                                final.clust <- final.clust$cluster
                }
        }
        if (control$cluster.only) 
                return(final.clust)
        return.val <- list(call = match.call(), d.num = d.num, tbl = results, 
                           extended.tbl = original.results, final.algorithm = final.algorithm, 
                           final.clust = final.clust, additional.args = additional.args)
        if (control$return.trees) 
                return.val$trees <- big.list.of.trees
        if (control$return.dists) 
                return.val$dists <- dists
        if (control$return.newdata) 
                return.val$newdata <- newdata
        if (control$return.mat) 
                if (!missing(final.algorithm) && is.element(final.algorithm, 
                                                            c("clara", "kmeans"))) 
                        return.val$mat <- newdata
        else return.val$mat <- leaf.matrix
        class(return.val) <- "treeClust"
        return(return.val)
}
